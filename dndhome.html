<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>D&D Timeline with Triangles & Zoom</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%;
    background-color: #1e1e2f;
    color: white;
    font-family: Arial, sans-serif;
    overflow: hidden;
  }

  #timeline-container {
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    position: relative;
    cursor: grab;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  #timeline {
    position: relative;
    height: 6px;
    background-color: #888;
    user-select: none;
    transition: transform 0.05s ease-out;
  }

  .year-marker {
    position: absolute;
    top: -15px;
    width: 2px;
    height: 30px;
    background: #ccc;
  }

  .year-label {
    position: absolute;
    top: 20px;
    font-size: 12px;
    color: #aaa;
    white-space: nowrap;
    transform: translateX(-50%);
    user-select: none;
  }

  /* Triangle marker base */
  .event-marker {
    position: absolute;
    width: 0; 
    height: 0;
    border-style: solid;
    cursor: pointer;
    user-select: none;
    transition: filter 0.2s;
  }
  /* Types of triangles */
  .historic {
    border-width: 10px 8.7px 0 8.7px;
    border-color: #4caf50 transparent transparent transparent;
  }
  .divine {
    border-width: 0 8.7px 10px 8.7px;
    border-color: transparent transparent #fbc02d transparent;
  }
  .city {
    border-width: 10px 10px 10px 0;
    border-color: transparent #2196f3 transparent transparent;
  }
  .battle {
    border-width: 10px 0 10px 10px;
    border-color: transparent transparent transparent #e91e63;
  }
  .magic {
    border-width: 10px 10px 0 10px;
    border-color: #9c27b0 transparent transparent transparent;
  }
  .arcane {
    border-width: 0 10px 10px 10px;
    border-color: transparent transparent #00bcd4 transparent;
  }

  .event-marker:hover {
    filter: brightness(1.5);
  }

  .event-marker:hover::after {
    content: attr(data-title);
    position: absolute;
    bottom: 150%;
    left: 50%;
    transform: translateX(-50%);
    background: #222;
    padding: 6px 10px;
    font-size: 14px;
    border-radius: 6px;
    white-space: nowrap;
    pointer-events: none;
    z-index: 10;
    opacity: 1;
  }
</style>
</head>
<body>

<div id="timeline-container">
  <div id="timeline"></div>
</div>

<script>
  const timeline = document.getElementById('timeline');
  const container = document.getElementById('timeline-container');

  const PIXELS_PER_100_YEARS = 150;

  let isDragging = false;
  let lastMouseX = 0;
  let lastMouseY = 0;
  let offsetX = 0;
  let offsetY = 0;
  let scale = 1;

  fetch('events.txt')
    .then(res => res.text())
    .then(text => {
      const lines = text.trim().split('\n');
      const events = lines.map(line => {
        const [yearStr, title, type = 'historic'] = line.split('|');
        return { year: parseInt(yearStr), title, type };
      });

      buildTimeline(events);
    })
    .catch(err => {
      timeline.innerHTML = '<p style="color:#f44;">Error loading events.txt</p>';
      console.error(err);
    });

  function buildTimeline(events) {
    if (events.length === 0) return;

    const years = events.map(e => e.year);
    const minYear = Math.floor(Math.min(...years) / 100) * 100 - 200;
    const maxYear = Math.ceil(Math.max(...years) / 100) * 100 + 200;

    const yearRange = maxYear - minYear;
    const timelineWidth = (yearRange / 100) * PIXELS_PER_100_YEARS;

    timeline.style.width = timelineWidth + 'px';

    timeline.innerHTML = '';

    // Year markers & labels
    for (let year = minYear; year <= maxYear; year += 100) {
      const posX = ((year - minYear) / 100) * PIXELS_PER_100_YEARS;

      const yearMark = document.createElement('div');
      yearMark.className = 'year-marker';
      yearMark.style.left = posX + 'px';
      timeline.appendChild(yearMark);

      const yearLabel = document.createElement('div');
      yearLabel.className = 'year-label';
      yearLabel.style.left = posX + 'px';
      yearLabel.textContent = year + ' DR';
      timeline.appendChild(yearLabel);
    }

    // Event markers
    for (const event of events) {
      const posX = ((event.year - minYear) / 100) * PIXELS_PER_100_YEARS;

      const marker = document.createElement('div');
      marker.className = `event-marker ${event.type.toLowerCase()}`;
      marker.style.left = posX + 'px';
      marker.dataset.title = event.title;
      timeline.appendChild(marker);
    }

    // Center timeline initially
    offsetX = (container.clientWidth / 2) - (timelineWidth / 2);
    offsetY = 0;
    scale = 1;
    updateTransform();
  }

  // Drag handlers
  container.addEventListener('mousedown', e => {
    isDragging = true;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
    container.style.cursor = 'grabbing';
  });

  window.addEventListener('mouseup', () => {
    isDragging = false;
    container.style.cursor = 'grab';
  });

  window.addEventListener('mousemove', e => {
    if (!isDragging) return;
    const dx = e.clientX - lastMouseX;
    const dy = e.clientY - lastMouseY;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;

    offsetX += dx;
    offsetY += dy;

    updateTransform();
  });

  // Zoom centered on viewport center
  container.addEventListener('wheel', e => {
    e.preventDefault();

    const zoomSpeed = 0.0015;
    const oldScale = scale;
    scale -= e.deltaY * zoomSpeed;
    scale = Math.min(Math.max(scale, 0.2), 5);

    // Zoom pivot = center of container
    const pivotX = container.clientWidth / 2;
    const pivotY = container.clientHeight / 2;

    offsetX -= (pivotX) * (scale - oldScale);
    offsetY -= (pivotY) * (scale - oldScale);

    updateTransform();
  }, { passive: false });

  function updateTransform() {
    timeline.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
  }
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>D&D Horizontal Timeline</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%;
    background-color: #1e1e2f;
    color: white;
    font-family: Arial, sans-serif;
    overflow: hidden;
  }

  #timeline-container {
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    position: relative;
    cursor: grab;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  #timeline {
    position: relative;
    height: 6px;
    background-color: #888;
    /* width will be set dynamically */
    user-select: none;
  }

  .year-marker {
    position: absolute;
    top: -15px;
    width: 2px;
    height: 30px;
    background: #ccc;
  }

  .year-label {
    position: absolute;
    top: 20px;
    font-size: 12px;
    color: #aaa;
    white-space: nowrap;
    transform: translateX(-50%);
    user-select: none;
  }

  .event-marker {
    position: absolute;
    top: -20px;
    width: 14px;
    height: 14px;
    background: #4caf50;
    border-radius: 50%;
    border: 2px solid #fff;
    cursor: pointer;
    user-select: none;
  }

  .event-marker:hover::after {
    content: attr(data-title) " - " attr(data-description);
    position: absolute;
    bottom: 150%;
    left: 50%;
    transform: translateX(-50%);
    background: #222;
    padding: 6px 10px;
    font-size: 14px;
    border-radius: 6px;
    white-space: nowrap;
    pointer-events: none;
    z-index: 10;
    opacity: 1;
  }
</style>
</head>
<body>

<div id="timeline-container">
  <div id="timeline"></div>
</div>

<script>
  const timeline = document.getElementById('timeline');
  const container = document.getElementById('timeline-container');

  // Pixels per 100 years
  const PIXELS_PER_100_YEARS = 150;

  // Variables for panning and zooming
  let isDragging = false;
  let lastMouseX = 0;
  let lastMouseY = 0;
  let offsetX = 0;
  let offsetY = 0;
  let scale = 1;

  // Load and parse events
  fetch('events.txt')
    .then(res => res.text())
    .then(text => {
      const lines = text.trim().split('\n');
      const events = lines.map(line => {
        const [yearStr, title, desc] = line.split('|');
        return { year: parseInt(yearStr), title, desc };
      });

      buildTimeline(events);
    })
    .catch(err => {
      timeline.innerHTML = '<p style="color:#f44;">Error loading events.txt</p>';
      console.error(err);
    });

  function buildTimeline(events) {
    if (events.length === 0) return;

    // Determine range of years with some padding
    const years = events.map(e => e.year);
    const minYear = Math.floor(Math.min(...years) / 100) * 100 - 200;
    const maxYear = Math.ceil(Math.max(...years) / 100) * 100 + 200;

    // Calculate timeline width based on range
    const yearRange = maxYear - minYear;
    const timelineWidth = (yearRange / 100) * PIXELS_PER_100_YEARS;

    timeline.style.width = timelineWidth + 'px';
    timeline.style.height = '6px';

    // Clear old markers if any
    timeline.innerHTML = '';

    // Add year markers and labels every 100 years
    for (let year = minYear; year <= maxYear; year += 100) {
      const posX = ((year - minYear) / 100) * PIXELS_PER_100_YEARS;

      // Year tick
      const yearMark = document.createElement('div');
      yearMark.className = 'year-marker';
      yearMark.style.left = posX + 'px';
      timeline.appendChild(yearMark);

      // Year label
      const yearLabel = document.createElement('div');
      yearLabel.className = 'year-label';
      yearLabel.style.left = posX + 'px';
      yearLabel.textContent = year + ' DR';
      timeline.appendChild(yearLabel);
    }

    // Add event markers
    for (const event of events) {
      const posX = ((event.year - minYear) / 100) * PIXELS_PER_100_YEARS;

      const marker = document.createElement('div');
      marker.className = 'event-marker';
      marker.style.left = posX + 'px';
      marker.dataset.title = event.title;
      marker.dataset.description = event.desc;
      timeline.appendChild(marker);
    }

    // Reset pan and zoom to center timeline in view
    offsetX = (container.clientWidth / 2) - (timelineWidth / 2);
    offsetY = 0;
    scale = 1;
    updateTransform();
  }

  // Panning drag events
  container.addEventListener('mousedown', e => {
    isDragging = true;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
    container.style.cursor = 'grabbing';
  });

  window.addEventListener('mouseup', () => {
    isDragging = false;
    container.style.cursor = 'grab';
  });

  window.addEventListener('mousemove', e => {
    if (!isDragging) return;
    const dx = e.clientX - lastMouseX;
    const dy = e.clientY - lastMouseY;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;

    offsetX += dx;
    offsetY += dy;

    updateTransform();
  });

  // Zoom on wheel (no Ctrl needed), zoom centered on mouse position
  container.addEventListener('wheel', e => {
    e.preventDefault();

    const zoomSpeed = 0.0015;
    const oldScale = scale;
    scale -= e.deltaY * zoomSpeed;
    scale = Math.min(Math.max(scale, 0.2), 5);

    // Calculate mouse position relative to timeline left edge
    const rect = timeline.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;

    // Adjust offset to zoom towards mouse pointer
    offsetX -= (mouseX) * (scale - oldScale);

    updateTransform();
  }, { passive: false });

  function updateTransform() {
    timeline.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
  }
</script>

</body>
</html>

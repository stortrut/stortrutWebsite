<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Zoomable Timeline — Eras & Events Above Ticks</title>
<style>
  * { box-sizing: border-box; }
  body {
    margin: 0;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: #f5f5f5;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    padding: 12px;
  }

  #controls {
    display:flex;
    gap:8px;
    align-items:center;
  }
  button { padding:8px 12px; font-size:14px; }

  #timeline-container {
    width: 100%;
    max-width: 1200px;
    height: 360px;
    background: #fff;
    border: 1px solid #ccc;
    overflow: hidden;
    position: relative;
    cursor: grab;
  }

  #timeline {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    transform-origin: 0 0;
    will-change: transform;
  }

  .era-band {
    position: absolute;
    top: 0;
    height: 100%;
    opacity: 0.06;
    pointer-events: none;
  }

  .era-label {
    position: absolute;
    top: 8px;
    font-size: 13px;
    color: #333;
    transform: translateX(-50%);
    pointer-events: none;
    background: rgba(255,255,255,0.6);
    padding: 2px 6px;
    border-radius: 4px;
  }

  .axis {
    position: absolute;
    left: 0;
    right: 0;
    height: 1px;
    background: #eee;
    top: 60%;
  }

  .tick {
    position: absolute;
    width: 1px;
    bottom: 40px;    /* tick bottom (so ticks are below events baseline) */
    height: 50px;    /* tick height */
    background: #333;
  }

  .tick-year {
    position: absolute;
    bottom: 12px;    /* place year labels near bottom (below tick) */
    transform: translateX(-50%);
    font-size: 12px;
    white-space: nowrap;
    pointer-events: none;
    color: #222;
    background: rgba(255,255,255,0.85);
    padding: 1px 4px;
    border-radius: 3px;
  }

  .event {
    position: absolute;
    transform: translateX(-50%);
    font-size: 12px;
    white-space: nowrap;
    background: #fff;
    padding: 4px 6px;
    border-radius: 4px;
    border: 1px solid #bbb;
    box-shadow: 0 1px 2px rgba(0,0,0,0.06);
    z-index: 60;
    display: inline-block;
  }

  .event .arrow-up {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    top: 100%;
    width: 0;
    height: 0;
    border-left: 6px solid transparent;
    border-right: 6px solid transparent;
    border-top: 8px solid #bbb;
  }

  @media (max-width:600px){
    .tick-year { font-size: 11px; }
    .event { font-size: 11px; padding:3px 5px; }
  }
</style>
</head>
<body>

<div id="controls">
  <button id="zoom-out">Zoom Out −</button>
  <button id="zoom-in">Zoom In +</button>
  <label style="margin-left:12px; font-size:13px; color:#444;">
    Wheel to zoom (hover), drag to pan. Events sit above ticks. Eras supported.
  </label>
</div>

<div id="timeline-container" aria-label="timeline container">
  <div id="timeline" aria-hidden="false"></div>
</div>

<!-- CONFIG: define eras and events here -->
<script id="timeline-config" type="application/json">
{
  "eras": [
    { "name": "The First Era", "length": 9000, "suffix": "1TP", "color": "#6fa8dc" },
    { "name": "The Second Era", "length": 5000, "suffix": "2TP", "color": "#93c47d" }
  ],
  "events": [
    { "era": 0, "year": 50, "label": "Battle of Something" },
    { "era": 0, "year": 102, "label": "Coronation" },
    { "era": 0, "year": 105, "label": "Treaty Signed" },
    { "era": 0, "year": 400, "label": "Great Discovery" },
    { "era": 0, "year": 800, "label": "Mysterious Event" },
    { "era": 1, "year": 1, "label": "Second Era Start Event" },
    { "era": 1, "year": 802, "label": "Close Again (in era2)" }
  ]
}
</script>

<script>
(() => {
  // --- Parse config and prepare era/global mapping ---
  const cfg = JSON.parse(document.getElementById('timeline-config').textContent.trim());
  const eras = (Array.isArray(cfg.eras) && cfg.eras.length) ? cfg.eras : [{name:'Era 1', length: (cfg.endYear && cfg.startYear) ? cfg.endYear - cfg.startYear : 1000, suffix: ''}];
  // Ensure era fields
  eras.forEach((e, i) => {
    if (typeof e.length !== 'number' || e.length <= 0) e.length = 1000;
    if (typeof e.name !== 'string') e.name = 'Era ' + (i+1);
    if (typeof e.suffix !== 'string') e.suffix = '';
    if (typeof e.color !== 'string') {
      // pick mild palette if not specified
      const palette = ['#6fa8dc','#93c47d','#f6b26b','#c27ba0','#8e7cc3'];
      e.color = palette[i % palette.length];
    }
  });

  // build cumulative start positions (global years)
  const eraStarts = [];
  let acc = 0;
  for (const e of eras) {
    eraStarts.push(acc);
    acc += e.length;
  }
  const totalYears = Math.max(1, acc);

  // map events: support era/year format (preferred), or fallback to {globalYear: N}
  const rawEvents = Array.isArray(cfg.events) ? cfg.events : [];
  const events = [];
  rawEvents.forEach(re => {
    if (typeof re.era === 'number' && typeof re.year === 'number') {
      const eraIndex = Math.max(0, Math.min(eras.length - 1, re.era));
      const yearInEra = Math.max(0, Math.min(eras[eraIndex].length, Math.round(re.year)));
      const global = eraStarts[eraIndex] + yearInEra;
      events.push({ era: eraIndex, year: yearInEra, globalYear: global, label: re.label || '' });
    } else if (typeof re.globalYear === 'number' || typeof re.year === 'number') {
      // fallback: treat provided `year` as global year
      const global = Math.round(re.globalYear ?? re.year);
      let eraIndex = 0;
      while (eraIndex < eras.length - 1 && global >= eraStarts[eraIndex + 1]) eraIndex++;
      const yearInEra = Math.max(0, global - eraStarts[eraIndex]);
      events.push({ era: eraIndex, year: yearInEra, globalYear: global, label: re.label || '' });
    } else {
      // ignore malformed event
    }
  });

  // --- DOM refs and state ---
  const container = document.getElementById('timeline-container');
  const timeline = document.getElementById('timeline');
  const btnZoomIn = document.getElementById('zoom-in');
  const btnZoomOut = document.getElementById('zoom-out');

  // parameters
  let basePixelsPerYear = 1; // computed at init
  let zoom = 1;
  const minZoom = 0.01;
  const maxZoom = 100;

  const edgeMarginPx = 90; // margin inside timeline so first/last years have breathing room

  let panX = 0; // applied translateX (positive moves timeline right)

  function containerW() { return container.clientWidth; }
  function containerH() { return container.clientHeight; }

  function yearSpanPixelsForZoom(z = zoom) {
    return basePixelsPerYear * totalYears * z;
  }
  function timelineWidthForZoom(z = zoom) {
    return yearSpanPixelsForZoom(z) + 2 * edgeMarginPx;
  }
  function timelineLeftForWidth(tw) {
    return (containerW() - tw) / 2;
  }

  function normalizedForGlobalYear(gYear) {
    return gYear / totalYears; // 0..1
  }

  function xInTimelineForGlobalYear(gYear, tw) {
    const span = yearSpanPixelsForZoom(zoom);
    const norm = normalizedForGlobalYear(gYear);
    return edgeMarginPx + norm * span;
  }

  function xInContainerForGlobalYear(gYear, tw) {
    const left = timelineLeftForWidth(tw);
    return left + panX + xInTimelineForGlobalYear(gYear, tw);
  }

  function clampPanFor(tw) {
    const left = timelineLeftForWidth(tw);
    if (tw <= containerW()) {
      return 0;
    } else {
      const maxPan = -left;
      const minPan = containerW() - (left + tw);
      if (panX > maxPan) return maxPan;
      if (panX < minPan) return minPan;
      return panX;
    }
  }

  function tickStepFor(tw) {
    const pxPerYear = (tw - 2*edgeMarginPx) / totalYears;
    if (pxPerYear >= 80) return 1;
    if (pxPerYear >= 30) return 2;
    if (pxPerYear >= 12) return 5;
    if (pxPerYear >= 6) return 10;
    if (pxPerYear >= 2.5) return 50;
    return 100;
  }

  // --- Helpers to convert globalYear -> era/year label ---
  function eraIndexForGlobalYear(gYear) {
    // binary search or linear (eras small)
    for (let i = eras.length - 1; i >= 0; i--) {
      if (gYear >= eraStarts[i]) return i;
    }
    return 0;
  }
  function labelForGlobalYear(gYear) {
    const ei = eraIndexForGlobalYear(gYear);
    const inEra = gYear - eraStarts[ei];
    const suffix = eras[ei].suffix ? ' ' + eras[ei].suffix : '';
    return `${inEra}${suffix}`; // e.g., "50 1TP"
  }
  function eraNameForGlobalYear(gYear) {
    const ei = eraIndexForGlobalYear(gYear);
    return eras[ei].name;
  }

  // --- Initialize base pixels so timeline is reasonably wide at zoom=1 ---
  function initBase() {
    const desiredSpanFactor = 2.0;
    basePixelsPerYear = Math.max(0.2, (containerW() * desiredSpanFactor) / Math.max(1, totalYears));
  }

  // Visible range in timeline-local coordinates:
  function visibleTimelineRange(tw) {
    const left = timelineLeftForWidth(tw);
    const xStart = - (left + panX);
    const xEnd = xStart + containerW();
    return { xStart, xEnd };
  }

  // Convert internal timeline-local x to globalYear (float)
  function globalYearForX(x, tw) {
    const yearSpan = yearSpanPixelsForZoom(zoom);
    const norm = (x - edgeMarginPx) / (yearSpan || 1);
    return Math.max(0, Math.min(totalYears, norm * totalYears));
  }

  // Render: only visible ticks and visible events (with buffer)
  function render() {
    timeline.innerHTML = '';

    const tw = timelineWidthForZoom(zoom);
    const left = timelineLeftForWidth(tw);
    timeline.style.width = Math.max(tw, 1) + 'px';
    timeline.style.height = containerH() + 'px';
    timeline.style.transform = `translateX(${left + panX}px)`;

    // Era bands (simple subtle background per era)
    for (let i = 0; i < eras.length; i++) {
      const eraStartGlobal = eraStarts[i];
      const eraLen = eras[i].length;
      // compute local x and width
      const x0 = xInTimelineForGlobalYear(eraStartGlobal, tw);
      const x1 = xInTimelineForGlobalYear(eraStartGlobal + eraLen, tw);
      const band = document.createElement('div');
      band.className = 'era-band';
      band.style.left = x0 + 'px';
      band.style.width = Math.max(0, x1 - x0) + 'px';
      band.style.background = eras[i].color;
      timeline.appendChild(band);

      // era label centered in the era band (only if band visible enough)
      const bandCenter = x0 + (x1 - x0) / 2;
      const containerLeft = left + panX;
      const containerRight = containerLeft + containerW();
      const bandLeftInContainer = containerLeft + band.offsetLeft; // note: offsetLeft isn't accurate pre-append reading; we compute visibility by comparing x0..x1 to visible range below
      // We'll render era label based on visibility using visible range:
    }

    // axis baseline
    const axis = document.createElement('div');
    axis.className = 'axis';
    timeline.appendChild(axis);

    // visible window (with buffer)
    const bufferPx = Math.max(200, containerW() * 0.25);
    const { xStart, xEnd } = visibleTimelineRange(tw);
    const visStart = xStart - bufferPx;
    const visEnd = xEnd + bufferPx;

    // Draw ticks that are inside visible range
    const step = tickStepFor(tw);
    // global years to display
    let startGlobal = Math.floor(globalYearForX(visStart, tw));
    let endGlobal = Math.ceil(globalYearForX(visEnd, tw));
    startGlobal = Math.max(0, startGlobal);
    endGlobal = Math.min(totalYears, endGlobal);

    // align first tick to step
    const firstTick = Math.floor(startGlobal / step) * step;
    for (let gy = firstTick; gy <= endGlobal; gy += step) {
      if (gy < 0) continue;
      if (gy > totalYears) break;
      const xLocal = xInTimelineForGlobalYear(gy, tw);
      if (xLocal < visStart || xLocal > visEnd) continue;

      const tick = document.createElement('div');
      tick.className = 'tick';
      tick.style.left = xLocal + 'px';
      timeline.appendChild(tick);

      const lbl = document.createElement('div');
      lbl.className = 'tick-year';
      lbl.textContent = labelForGlobalYear(gy);
      lbl.style.left = xLocal + 'px';
      timeline.appendChild(lbl);
    }

    // render era labels (only those that intersect visible range)
    for (let i = 0; i < eras.length; i++) {
      const eraStartGlobal = eraStarts[i];
      const eraLen = eras[i].length;
      const x0 = xInTimelineForGlobalYear(eraStartGlobal, tw);
      const x1 = xInTimelineForGlobalYear(eraStartGlobal + eraLen, tw);
      if (x1 < visStart || x0 > visEnd) continue;
      const eraLabel = document.createElement('div');
      eraLabel.className = 'era-label';
      eraLabel.textContent = eras[i].name;
      // place label near top of timeline and centered within era band (clamped to visible area)
      const bandCenter = x0 + (x1 - x0) / 2;
      eraLabel.style.left = bandCenter + 'px';
      timeline.appendChild(eraLabel);
    }

    // Visible events
    const visibleEvents = [];
    for (const ev of events) {
      const xLocal = xInTimelineForGlobalYear(ev.globalYear, tw);
      if (xLocal >= visStart && xLocal <= visEnd) visibleEvents.push({ ev, xLocal });
    }
    visibleEvents.sort((a,b) => a.ev.globalYear - b.ev.globalYear);

    // Place events above ticks: ensure event bottom is above tick top
    // tick top (distance from bottom) = tick bottom + tick height = 40 + 50 = 90
    const tickTop = 40 + 50;
    const baseBottom = tickTop + 20; // events start 20px above tick top
    const placed = [];
    for (const item of visibleEvents) {
      const ev = item.ev;
      const xLocal = item.xLocal;
      const el = document.createElement('div');
      el.className = 'event';
      // Show label and optionally era/year suffix in tooltip (not mandatory)
      el.textContent = ev.label;
      // Add small era/year hint on a second span, optional:
      const hint = document.createElement('span');
      hint.style.fontSize = '11px';
      hint.style.opacity = '0.75';
      hint.style.marginLeft = '6px';
      hint.textContent = `(${ev.year} ${eras[ev.era].suffix})`;
      // Append as small muted text if you want: commented to keep label clean:
      // el.appendChild(hint);

      el.style.left = xLocal + 'px';
      el.style.bottom = baseBottom + 'px';

      const arrow = document.createElement('div');
      arrow.className = 'arrow-up';
      el.appendChild(arrow);
      timeline.appendChild(el);

      // Stacking by actual bounding-box collision
      let stackLevel = 0;
      const MAX_STACK = 60;
      function rect(node) { return node.getBoundingClientRect(); }
      // measure after inserted
      el.style.bottom = (baseBottom + stackLevel * 30) + 'px';
      let r = rect(el);
      while (true) {
        let collided = false;
        for (const other of placed) {
          const ro = rect(other);
          const horiz = !(r.right <= ro.left || r.left >= ro.right);
          const vert  = !(r.bottom <= ro.top || r.top >= ro.bottom);
          if (horiz && vert) { collided = true; break; }
        }
        if (!collided) break;
        stackLevel++;
        if (stackLevel > MAX_STACK) break;
        el.style.bottom = (baseBottom + stackLevel * 30) + 'px';
        r = rect(el);
      }
      placed.push(el);
    }

    // clamp pan and re-apply translate (in case content size changed)
    panX = clampPanFor(tw);
    timeline.style.transform = `translateX(${left + panX}px)`;
  }

  // Zoom centered on containerX (relative to container)
  function performZoom(factor, containerX = null) {
    const oldTw = timelineWidthForZoom(zoom);
    const oldZoom = zoom;
    const newZoom = Math.min(maxZoom, Math.max(minZoom, zoom * factor));
    if (newZoom === zoom) return;
    if (containerX === null) containerX = containerW() / 2;

    // normalized position inside timeline under containerX before zoom
    const leftOld = timelineLeftForWidth(oldTw);
    const xInTimeline_old = containerX - (leftOld + panX);
    // compute normalized within the yearSpan (0..1)
    const norm = (xInTimeline_old - edgeMarginPx) / (yearSpanPixelsForZoom(oldZoom) || 1);
    const normClamped = Math.min(Math.max(norm, 0), 1);

    // apply new zoom
    zoom = newZoom;

    // compute new positions
    const newTw = timelineWidthForZoom(zoom);
    const leftNew = timelineLeftForWidth(newTw);

    // pan so same normalized point remains under containerX
    panX = containerX - leftNew - (edgeMarginPx + normClamped * yearSpanPixelsForZoom(zoom));
    panX = clampPanFor(newTw);
    render();
  }

  // Drag/pan handlers
  let dragging = false;
  let lastX = 0;
  function startDrag(clientX) { dragging = true; lastX = clientX; container.style.cursor = 'grabbing'; }
  function endDrag() { dragging = false; container.style.cursor = 'grab'; }
  function moveDrag(clientX) {
    if (!dragging) return;
    const dx = clientX - lastX;
    lastX = clientX;
    panX += dx;
    panX = clampPanFor(timelineWidthForZoom(zoom));
    render();
  }

  // wheel zoom
  function handleWheel(e) {
    if (e.ctrlKey || e.metaKey) return;
    e.preventDefault();
    const delta = e.deltaY || -e.wheelDelta;
    const factor = delta < 0 ? 1.12 : 1 / 1.12;
    const rect = container.getBoundingClientRect();
    const x = e.clientX - rect.left;
    performZoom(factor, x);
  }

  // touch pinch + pan
  let touchState = { pinchStartDist: null, pinchStartZoom: null, lastMidX: null };
  container.addEventListener('touchstart', (ev) => {
    if (ev.touches.length === 1) startDrag(ev.touches[0].clientX);
    else if (ev.touches.length === 2) {
      const a = ev.touches[0], b = ev.touches[1];
      touchState.pinchStartDist = Math.hypot(b.clientX - a.clientX, b.clientY - a.clientY);
      touchState.pinchStartZoom = zoom;
      touchState.lastMidX = (a.clientX + b.clientX) / 2 - container.getBoundingClientRect().left;
    }
  }, { passive: false });

  container.addEventListener('touchmove', (ev) => {
    if (ev.touches.length === 1 && dragging) moveDrag(ev.touches[0].clientX);
    else if (ev.touches.length === 2 && touchState.pinchStartDist) {
      const a = ev.touches[0], b = ev.touches[1];
      const dist = Math.hypot(b.clientX - a.clientX, b.clientY - a.clientY);
      const factor = dist / touchState.pinchStartDist;
      const newZoom = Math.min(maxZoom, Math.max(minZoom, touchState.pinchStartZoom * factor));
      const ratio = newZoom / zoom;
      performZoom(ratio, touchState.lastMidX);
    }
    ev.preventDefault();
  }, { passive: false });

  container.addEventListener('touchend', () => { endDrag(); touchState = { pinchStartDist: null, pinchStartZoom: null, lastMidX: null }; });

  // mouse
  container.addEventListener('mousedown', (e) => { startDrag(e.clientX); });
  window.addEventListener('mouseup', (e) => { endDrag(); });
  window.addEventListener('mousemove', (e) => { moveDrag(e.clientX); });
  container.addEventListener('wheel', handleWheel, { passive: false });

  // zoom buttons
  btnZoomIn.addEventListener('click', () => performZoom(1.4, containerW()/2));
  btnZoomOut.addEventListener('click', () => performZoom(1/1.4, containerW()/2));

  // responsive init
  let resizeTimer = null;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      const centerX = containerW()/2;
      // preserve center normalized position
      const twOld = timelineWidthForZoom(zoom);
      const leftOld = timelineLeftForWidth(twOld);
      const xInTimeline_old = centerX - (leftOld + panX);
      const norm = (xInTimeline_old - edgeMarginPx) / (yearSpanPixelsForZoom(zoom) || 1);
      initBase();
      const newTw = timelineWidthForZoom(zoom);
      const leftNew = timelineLeftForWidth(newTw);
      panX = centerX - leftNew - (edgeMarginPx + norm * yearSpanPixelsForZoom(zoom));
      panX = clampPanFor(newTw);
      render();
    }, 120);
  });

  function start() {
    initBase();
    panX = 0;
    render();
    container.style.cursor = 'grab';
  }

  // expose for debugging/tweaks
  window.TimelineAPI = {
    render, performZoom,
    state: () => ({ zoom, panX, basePixelsPerYear, totalYears, eraStarts, eras })
  };

  start();
})();
</script>
</body>
</html>

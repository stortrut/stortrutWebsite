<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Zoomable Timeline — 1k / 10k Tick Levels</title>
<style>
  * { box-sizing: border-box; }
  body {
    margin: 0;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: #f5f5f5;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    padding: 12px;
  }

  #controls {
    display:flex;
    gap:8px;
    align-items:center;
  }
  button { padding:8px 12px; font-size:14px; }

  #timeline-container {
    width: 100%;
    max-width: 1200px;
    height: 360px;
    background: #fff;
    border: 1px solid #ccc;
    overflow: hidden;
    position: relative;
    cursor: grab;
  }

  #timeline {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    transform-origin: 0 0;
    will-change: transform;
  }

  .era-band {
    position: absolute;
    top: 0;
    height: 100%;
    opacity: 0.06;
    pointer-events: none;
  }

  .era-label {
    position: absolute;
    top: 8px;
    font-size: 13px;
    color: #333;
    transform: translateX(-50%);
    pointer-events: none;
    background: rgba(255,255,255,0.6);
    padding: 2px 6px;
    border-radius: 4px;
  }

  .axis {
    position: absolute;
    left: 0;
    right: 0;
    height: 1px;
    background: #eee;
    top: 60%;
  }

  /* default tick style; will override height/bottom inline for different levels */
  .tick {
    position: absolute;
    width: 1px;
    background: #333;
  }

  .tick-year {
    position: absolute;
    bottom: 12px;
    transform: translateX(-50%);
    font-size: 12px;
    white-space: nowrap;
    pointer-events: none;
    color: #222;
    background: rgba(255,255,255,0.85);
    padding: 1px 4px;
    border-radius: 3px;
  }

  .event {
    position: absolute;
    transform: translateX(-50%);
    font-size: 12px;
    white-space: nowrap;
    background: #fff;
    padding: 4px 6px;
    border-radius: 4px;
    border: 1px solid #bbb;
    box-shadow: 0 1px 2px rgba(0,0,0,0.06);
    z-index: 60;
    display: inline-block;
  }

  .event .arrow-up {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    top: 100%;
    width: 0;
    height: 0;
    border-left: 6px solid transparent;
    border-right: 6px solid transparent;
    border-top: 8px solid #bbb;
  }

  @media (max-width:600px){
    .tick-year { font-size: 11px; }
    .event { font-size: 11px; padding:3px 5px; }
  }
</style>
</head>
<body>

<div id="controls">
  <button id="zoom-out">Zoom Out −</button>
  <button id="zoom-in">Zoom In +</button>
  <label style="margin-left:12px; font-size:13px; color:#444;">
    Wheel to zoom (hover), drag to pan. Major 1k/10k ticks hide smaller ticks.
  </label>
</div>

<div id="timeline-container" aria-label="timeline container">
  <div id="timeline" aria-hidden="false"></div>
</div>

<!-- CONFIG: define eras and events here -->
<script id="timeline-config" type="application/json">
{
  "eras": [
    { "name": "The First Era", "length": 9000, "suffix": "1TP", "color": "#6fa8dc" },
    { "name": "The Second Era", "length": 5000, "suffix": "2TP", "color": "#93c47d" }
  ],
  "events": [
    { "era": 0, "year": 50, "label": "Battle of Something" },
    { "era": 0, "year": 102, "label": "Coronation" },
    { "era": 0, "year": 105, "label": "Treaty Signed" },
    { "era": 0, "year": 400, "label": "Great Discovery" },
    { "era": 0, "year": 800, "label": "Mysterious Event" },
    { "era": 1, "year": 1, "label": "Second Era Start Event" },
    { "era": 1, "year": 802, "label": "Close Again (in era2)" }
  ]
}
</script>

<script>
(() => {
  // parse config
  const cfg = JSON.parse(document.getElementById('timeline-config').textContent.trim());
  const eras = (Array.isArray(cfg.eras) && cfg.eras.length) ? cfg.eras : [{name:'Era 1', length:1000, suffix:''}];
  eras.forEach((e,i) => {
    if (typeof e.length !== 'number' || e.length <= 0) e.length = 1000;
    if (typeof e.name !== 'string') e.name = 'Era ' + (i+1);
    if (typeof e.suffix !== 'string') e.suffix = '';
    if (typeof e.color !== 'string') {
      const palette = ['#6fa8dc','#93c47d','#f6b26b','#c27ba0','#8e7cc3'];
      e.color = palette[i % palette.length];
    }
  });

  // cumulative era starts
  const eraStarts = [];
  let acc = 0;
  for (const e of eras) { eraStarts.push(acc); acc += e.length; }
  const totalYears = Math.max(1, acc);

  // map events into global year
  const rawEvents = Array.isArray(cfg.events) ? cfg.events.slice() : [];
  const events = [];
  rawEvents.forEach(re => {
    if (typeof re.era === 'number' && typeof re.year === 'number') {
      const eraIndex = Math.max(0, Math.min(eras.length - 1, re.era));
      const yearInEra = Math.max(0, Math.min(eras[eraIndex].length, Math.round(re.year)));
      const global = eraStarts[eraIndex] + yearInEra;
      events.push({ era: eraIndex, year: yearInEra, globalYear: global, label: re.label || '' });
    } else if (typeof re.globalYear === 'number' || typeof re.year === 'number') {
      const global = Math.round(re.globalYear ?? re.year);
      let eraIndex = 0;
      while (eraIndex < eras.length - 1 && global >= eraStarts[eraIndex + 1]) eraIndex++;
      const yearInEra = Math.max(0, global - eraStarts[eraIndex]);
      events.push({ era: eraIndex, year: yearInEra, globalYear: global, label: re.label || '' });
    }
  });

  // DOM refs & state
  const container = document.getElementById('timeline-container');
  const timeline = document.getElementById('timeline');
  const btnZoomIn = document.getElementById('zoom-in');
  const btnZoomOut = document.getElementById('zoom-out');

  let basePixelsPerYear = 1;
  let zoom = 1;
  const minZoom = 0.01;
  const maxZoom = 100;
  const edgeMarginPx = 90;
  let panX = 0;

  function containerW() { return container.clientWidth; }
  function containerH() { return container.clientHeight; }

  function yearSpanPixelsForZoom(z = zoom) { return basePixelsPerYear * totalYears * z; }
  function timelineWidthForZoom(z = zoom) { return yearSpanPixelsForZoom(z) + 2 * edgeMarginPx; }
  function timelineLeftForWidth(tw) { return (containerW() - tw) / 2; }

  function normalizedForGlobalYear(gYear) { return gYear / totalYears; }
  function xInTimelineForGlobalYear(gYear, tw) {
    const span = yearSpanPixelsForZoom(zoom);
    const norm = normalizedForGlobalYear(gYear);
    return edgeMarginPx + norm * span;
  }

  function clampPanFor(tw) {
    const left = timelineLeftForWidth(tw);
    if (tw <= containerW()) return 0;
    const maxPan = -left;
    const minPan = containerW() - (left + tw);
    if (panX > maxPan) return maxPan;
    if (panX < minPan) return minPan;
    return panX;
  }

  function tickStepForAdaptive(tw) {
    const pxPerYear = (tw - 2*edgeMarginPx) / totalYears;
    if (pxPerYear >= 80) return 1;
    if (pxPerYear >= 30) return 2;
    if (pxPerYear >= 12) return 5;
    if (pxPerYear >= 6) return 10;
    if (pxPerYear >= 2.5) return 50;
    return 100;
  }

  // labeling helpers
  function eraIndexForGlobalYear(gYear) {
    for (let i = eras.length - 1; i >= 0; i--) if (gYear >= eraStarts[i]) return i;
    return 0;
  }
  function labelForGlobalYear(gYear) {
    const ei = eraIndexForGlobalYear(gYear);
    const inEra = Math.max(0, gYear - eraStarts[ei]);
    const suffix = eras[ei].suffix ? ' ' + eras[ei].suffix : '';
    return `${inEra}${suffix}`;
  }

  function initBase() {
    const desiredSpanFactor = 2.0;
    basePixelsPerYear = Math.max(0.2, (containerW() * desiredSpanFactor) / Math.max(1, totalYears));
  }

  function visibleTimelineRange(tw) {
    const left = timelineLeftForWidth(tw);
    const xStart = - (left + panX);
    const xEnd = xStart + containerW();
    return { xStart, xEnd };
  }

  function globalYearForX(x, tw) {
    const yearSpan = yearSpanPixelsForZoom(zoom);
    const norm = (x - edgeMarginPx) / (yearSpan || 1);
    return Math.max(0, Math.min(totalYears, norm * totalYears));
  }

  // NEW: thresholds for 1000 and 10000 tick visibility (tunable)
  function decideTickLevel(tw) {
    const pxPerYear = (tw - 2*edgeMarginPx) / totalYears;
    // If pxPerYear * 10000 >= threshold -> show only 10k ticks
    if (pxPerYear * 10000 >= 40) return { level: 10000, pxPerYear };
    // Else if pxPerYear * 1000 >= threshold -> show only 1k ticks
    if (pxPerYear * 1000 >= 20) return { level: 1000, pxPerYear };
    // else show adaptive smaller ticks
    return { level: 'adaptive', pxPerYear };
  }

  function render() {
    timeline.innerHTML = '';
    const tw = timelineWidthForZoom(zoom);
    const left = timelineLeftForWidth(tw);
    timeline.style.width = Math.max(tw, 1) + 'px';
    timeline.style.height = containerH() + 'px';
    timeline.style.transform = `translateX(${left + panX}px)`;

    // draw era bands
    for (let i = 0; i < eras.length; i++) {
      const eraStartGlobal = eraStarts[i];
      const eraLen = eras[i].length;
      const x0 = xInTimelineForGlobalYear(eraStartGlobal, tw);
      const x1 = xInTimelineForGlobalYear(eraStartGlobal + eraLen, tw);
      const band = document.createElement('div');
      band.className = 'era-band';
      band.style.left = x0 + 'px';
      band.style.width = Math.max(0, x1 - x0) + 'px';
      band.style.background = eras[i].color;
      timeline.appendChild(band);
    }

    // axis
    const axis = document.createElement('div');
    axis.className = 'axis';
    timeline.appendChild(axis);

    const bufferPx = Math.max(200, containerW() * 0.25);
    const { xStart, xEnd } = visibleTimelineRange(tw);
    const visStart = xStart - bufferPx;
    const visEnd = xEnd + bufferPx;

    // determine tick level
    const { level, pxPerYear } = decideTickLevel(tw);

    // decide tick heights: minor, mid(1k), major(10k)
    const tickBottom = 40; // baseline bottom for all ticks
    const minorHeight = 50;
    const midHeight = 70;
    const majorHeight = 90;
    let usedTickHeight = minorHeight;
    let step = 1;

    if (level === 10000) {
      step = 10000;
      usedTickHeight = majorHeight;
    } else if (level === 1000) {
      step = 1000;
      usedTickHeight = midHeight;
    } else { // adaptive
      step = tickStepForAdaptive(tw);
      usedTickHeight = minorHeight;
    }

    // compute visible global year range for ticks
    let startGlobal = Math.floor(globalYearForX(visStart, tw));
    let endGlobal = Math.ceil(globalYearForX(visEnd, tw));
    startGlobal = Math.max(0, startGlobal);
    endGlobal = Math.min(totalYears, endGlobal);

    // align first tick
    const firstTick = Math.floor(startGlobal / step) * step;

    // draw ticks at 'step' only (smaller ticks hidden when step=1000/10000)
    for (let gy = firstTick; gy <= endGlobal; gy += step) {
      if (gy < 0) continue;
      if (gy > totalYears) break;
      const xLocal = xInTimelineForGlobalYear(gy, tw);
      if (xLocal < visStart || xLocal > visEnd) continue;

      const tick = document.createElement('div');
      tick.className = 'tick';
      tick.style.left = xLocal + 'px';
      tick.style.bottom = tickBottom + 'px';
      tick.style.height = usedTickHeight + 'px';
      timeline.appendChild(tick);

      const lbl = document.createElement('div');
      lbl.className = 'tick-year';
      lbl.textContent = labelForGlobalYear(gy);
      // If the tick is major (10000) we may prefer to show the era name too — but keep it simple
      lbl.style.left = xLocal + 'px';
      timeline.appendChild(lbl);
    }

    // If desired: show sub-ticks between major ticks (optionally). For now we hide all smaller ticks per user request.

    // Era labels (visible bands)
    for (let i = 0; i < eras.length; i++) {
      const eraStartGlobal = eraStarts[i];
      const eraLen = eras[i].length;
      const x0 = xInTimelineForGlobalYear(eraStartGlobal, tw);
      const x1 = xInTimelineForGlobalYear(eraStartGlobal + eraLen, tw);
      if (x1 < visStart || x0 > visEnd) continue;
      const eraLabel = document.createElement('div');
      eraLabel.className = 'era-label';
      eraLabel.textContent = eras[i].name;
      const bandCenter = x0 + (x1 - x0) / 2;
      eraLabel.style.left = bandCenter + 'px';
      timeline.appendChild(eraLabel);
    }

    // EVENTS: place visible events and stack above the tallest visible tick
    let maxTickTop = tickBottom + usedTickHeight; // top of tick in px from bottom
    const baseBottom = maxTickTop + 20; // events start above this

    // gather visible events
    const visibleEvents = [];
    for (const ev of events) {
      const xLocal = xInTimelineForGlobalYear(ev.globalYear, tw);
      if (xLocal >= visStart && xLocal <= visEnd) visibleEvents.push({ ev, xLocal });
    }
    visibleEvents.sort((a,b) => a.ev.globalYear - b.ev.globalYear);

    const placed = [];
    for (const item of visibleEvents) {
      const ev = item.ev;
      const xLocal = item.xLocal;
      const el = document.createElement('div');
      el.className = 'event';
      el.textContent = ev.label;
      el.style.left = xLocal + 'px';
      el.style.bottom = baseBottom + 'px';
      const arrow = document.createElement('div');
      arrow.className = 'arrow-up';
      el.appendChild(arrow);
      timeline.appendChild(el);

      // stacking with bbox collision detection
      let stackLevel = 0;
      const MAX_STACK = 60;
      function rect(node) { return node.getBoundingClientRect(); }
      el.style.bottom = (baseBottom + stackLevel * 30) + 'px';
      let r = rect(el);
      while (true) {
        let collided = false;
        for (const other of placed) {
          const ro = rect(other);
          const horiz = !(r.right <= ro.left || r.left >= ro.right);
          const vert  = !(r.bottom <= ro.top || r.top >= ro.bottom);
          if (horiz && vert) { collided = true; break; }
        }
        if (!collided) break;
        stackLevel++;
        if (stackLevel > MAX_STACK) break;
        el.style.bottom = (baseBottom + stackLevel * 30) + 'px';
        r = rect(el);
      }
      placed.push(el);
    }

    // clamp pan & reapply transform
    panX = clampPanFor(tw);
    timeline.style.transform = `translateX(${left + panX}px)`;
  }

  // zoom keeping a point stable
  function performZoom(factor, containerX = null) {
    const oldTw = timelineWidthForZoom(zoom);
    const newZoom = Math.min(maxZoom, Math.max(minZoom, zoom * factor));
    if (newZoom === zoom) return;
    if (containerX === null) containerX = containerW() / 2;

    const leftOld = timelineLeftForWidth(oldTw);
    const xInTimeline_old = containerX - (leftOld + panX);
    const norm = (xInTimeline_old - edgeMarginPx) / (yearSpanPixelsForZoom(zoom) || 1);
    const normClamped = Math.min(Math.max(norm, 0), 1);

    zoom = newZoom;
    const newTw = timelineWidthForZoom(zoom);
    const leftNew = timelineLeftForWidth(newTw);

    panX = containerX - leftNew - (edgeMarginPx + normClamped * yearSpanPixelsForZoom(zoom));
    panX = clampPanFor(newTw);
    render();
  }

  // pan handlers
  let dragging = false;
  let lastX = 0;
  function startDrag(clientX) { dragging = true; lastX = clientX; container.style.cursor = 'grabbing'; }
  function endDrag() { dragging = false; container.style.cursor = 'grab'; }
  function moveDrag(clientX) { if (!dragging) return; const dx = clientX - lastX; lastX = clientX; panX += dx; panX = clampPanFor(timelineWidthForZoom(zoom)); render(); }

  // wheel zoom
  function handleWheel(e) {
    if (e.ctrlKey || e.metaKey) return;
    e.preventDefault();
    const delta = e.deltaY || -e.wheelDelta;
    const factor = delta < 0 ? 1.12 : 1 / 1.12;
    const rect = container.getBoundingClientRect();
    const x = e.clientX - rect.left;
    performZoom(factor, x);
  }

  // touch pinch + pan simplified
  let touchState = { pinchStartDist: null, pinchStartZoom: null, lastMidX: null };
  container.addEventListener('touchstart', (ev) => {
    if (ev.touches.length === 1) startDrag(ev.touches[0].clientX);
    else if (ev.touches.length === 2) {
      const a = ev.touches[0], b = ev.touches[1];
      touchState.pinchStartDist = Math.hypot(b.clientX - a.clientX, b.clientY - a.clientY);
      touchState.pinchStartZoom = zoom;
      touchState.lastMidX = (a.clientX + b.clientX) / 2 - container.getBoundingClientRect().left;
    }
  }, { passive: false });

  container.addEventListener('touchmove', (ev) => {
    if (ev.touches.length === 1 && dragging) moveDrag(ev.touches[0].clientX);
    else if (ev.touches.length === 2 && touchState.pinchStartDist) {
      const a = ev.touches[0], b = ev.touches[1];
      const dist = Math.hypot(b.clientX - a.clientX, b.clientY - a.clientY);
      const factor = dist / touchState.pinchStartDist;
      const newZoom = Math.min(maxZoom, Math.max(minZoom, touchState.pinchStartZoom * factor));
      const ratio = newZoom / zoom;
      performZoom(ratio, touchState.lastMidX);
    }
    ev.preventDefault();
  }, { passive: false });

  container.addEventListener('touchend', () => { endDrag(); touchState = { pinchStartDist: null, pinchStartZoom: null, lastMidX: null }; });

  // mouse events
  container.addEventListener('mousedown', (e) => { startDrag(e.clientX); });
  window.addEventListener('mouseup', (e) => { endDrag(); });
  window.addEventListener('mousemove', (e) => { moveDrag(e.clientX); });
  container.addEventListener('wheel', handleWheel, { passive: false });

  // zoom buttons
  btnZoomIn.addEventListener('click', () => performZoom(1.4, containerW()/2));
  btnZoomOut.addEventListener('click', () => performZoom(1/1.4, containerW()/2));

  // resize handling (preserve center)
  let resizeTimer = null;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      const centerX = containerW()/2;
      const twOld = timelineWidthForZoom(zoom);
      const leftOld = timelineLeftForWidth(twOld);
      const xInTimeline_old = centerX - (leftOld + panX);
      const norm = (xInTimeline_old - edgeMarginPx) / (yearSpanPixelsForZoom(zoom) || 1);
      initBase();
      const newTw = timelineWidthForZoom(zoom);
      const leftNew = timelineLeftForWidth(newTw);
      panX = centerX - leftNew - (edgeMarginPx + norm * yearSpanPixelsForZoom(zoom));
      panX = clampPanFor(newTw);
      render();
    }, 120);
  });

  function start() { initBase(); panX = 0; render(); container.style.cursor = 'grab'; }
  initBase();
  start();

  // debug
  window.TimelineAPI = { render, performZoom, state: () => ({ zoom, panX, basePixelsPerYear, totalYears }) };
})();
</script>

</body>
</html>

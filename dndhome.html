<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Zoomable Timeline — Improved Performance & Edge Margins</title>
<style>
  * { box-sizing: border-box; }
  body {
    margin: 0;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: #f5f5f5;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    padding: 12px;
  }

  #controls {
    display:flex;
    gap:8px;
    align-items:center;
  }
  button { padding:8px 12px; font-size:14px; }

  #timeline-container {
    width: 100%;
    max-width: 1200px;
    height: 340px;
    background: #fff;
    border: 1px solid #ccc;
    overflow: hidden;
    position: relative;
    cursor: grab;
  }

  #timeline {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    transform-origin: 0 0;
    will-change: transform;
  }

  .axis {
    position: absolute;
    left: 0;
    right: 0;
    height: 1px;
    background: #eee;
    top: 60%;
  }

  .tick {
    position: absolute;
    width: 1px;
    bottom: 60px;
    height: 60px;
    background: #333;
  }

  .tick-year {
    position: absolute;
    bottom: 22px;
    transform: translateX(-50%);
    font-size: 12px;
    white-space: nowrap;
    pointer-events: none;
    color: #222;
  }

  .event {
    position: absolute;
    transform: translateX(-50%);
    font-size: 12px;
    white-space: nowrap;
    background: #fff;
    padding: 4px 6px;
    border-radius: 4px;
    border: 1px solid #bbb;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    z-index: 50;
    display: inline-block;
  }

  .event .arrow-up {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    top: 100%;
    width: 0;
    height: 0;
    border-left: 6px solid transparent;
    border-right: 6px solid transparent;
    border-top: 8px solid #bbb;
  }

  @media (max-width:600px){
    .tick-year { font-size: 11px; }
    .event { font-size: 11px; padding:3px 5px; }
  }
</style>
</head>
<body>

<div id="controls">
  <button id="zoom-out">Zoom Out −</button>
  <button id="zoom-in">Zoom In +</button>
  <label style="margin-left:12px; font-size:13px; color:#444;">
    Wheel to zoom (hover), drag to pan.
  </label>
</div>

<div id="timeline-container" aria-label="timeline container">
  <div id="timeline" aria-hidden="false"></div>
</div>

<script id="timeline-config" type="application/json">
{
  "startYear": 0,
  "endYear": 900,
  "events": [
    { "year": 100, "label": "Battle of Something" },
    { "year": 102, "label": "Coronation" },
    { "year": 105, "label": "Treaty Signed" },
    { "year": 400, "label": "Great Discovery" },
    { "year": 800, "label": "Mysterious Event" },
    { "year": 801, "label": "Close Event" },
    { "year": 802, "label": "Close Again" }
  ]
}
</script>

<script>
(() => {
  const cfg = JSON.parse(document.getElementById('timeline-config').textContent.trim());
  const startYear = Number(cfg.startYear);
  const endYear = Number(cfg.endYear);
  const events = Array.isArray(cfg.events) ? cfg.events.slice() : [];

  const container = document.getElementById('timeline-container');
  const timeline = document.getElementById('timeline');
  const btnZoomIn = document.getElementById('zoom-in');
  const btnZoomOut = document.getElementById('zoom-out');

  const totalYears = Math.max(1, endYear - startYear);

  // Parameters you can tune:
  let basePixelsPerYear = 1; // initialized below
  let zoom = 1;
  const minZoom = 0.02;
  const maxZoom = 40;

  // Edge margin inside the timeline so first/last years are never flush with viewport edge:
  const edgeMarginPx = 80; // <--- main fix: margin on left/right inside timeline (adjustable)

  // Pan X (applied as translate). Positive pans timeline to the right.
  let panX = 0;

  function containerW() { return container.clientWidth; }
  function containerH() { return container.clientHeight; }

  // timeline inner width that maps year span (excluding edge margins)
  function yearSpanPixelsForZoom(z = zoom) {
    return basePixelsPerYear * totalYears * z;
  }

  // total timeline width including edge margins
  function timelineWidthForZoom(z = zoom) {
    return yearSpanPixelsForZoom(z) + 2 * edgeMarginPx;
  }

  // left offset of timeline inside container when centered (before pan)
  function timelineLeftForWidth(tw) {
    return (containerW() - tw) / 2;
  }

  // normalized for year 0..1
  function normalizedForYear(y) {
    return (y - startYear) / totalYears;
  }

  // internal x (inside timeline element) for a year, accounts for edgePadding
  function xInTimelineForYear(y, tw) {
    const yearSpan = yearSpanPixelsForZoom(zoom);
    const norm = normalizedForYear(y);
    return edgeMarginPx + norm * yearSpan;
  }

  // full container x for a year
  function xInContainerForYear(y, tw) {
    const left = timelineLeftForWidth(tw);
    return left + panX + xInTimelineForYear(y, tw);
  }

  // ensure pan doesn't show blank edges (clamp)
  function clampPanFor(tw) {
    const left = timelineLeftForWidth(tw);
    if (tw <= containerW()) {
      // center the timeline inside container
      return 0;
    } else {
      const maxPan = -left; // panX <= maxPan so visibleLeft >= 0
      const minPan = containerW() - (left + tw); // panX >= minPan so visibleRight <= containerW
      if (panX > maxPan) return maxPan;
      if (panX < minPan) return minPan;
      return panX;
    }
  }

  // determine tick step based on px per year (yearSpanPixels / totalYears / zoom cancels -> base*zoom)
  function tickStepFor(tw) {
    const pxPerYear = (tw - 2*edgeMarginPx) / totalYears; // effective per-year px
    if (pxPerYear >= 80) return 1;
    if (pxPerYear >= 30) return 2;
    if (pxPerYear >= 12) return 5;
    if (pxPerYear >= 6) return 10;
    if (pxPerYear >= 2.5) return 50;
    return 100;
  }

  // Initialize basePixelsPerYear
  function initBase() {
    // choose the desired timeline span at zoom = 1 relative to container to be wide
    const desiredSpanFactor = 2.0; // timeline width (excluding margins) ~ 2x container width
    basePixelsPerYear = Math.max(0.5, (containerW() * desiredSpanFactor) / Math.max(1, totalYears));
  }

  // Compute visible range in timeline internal coordinates (timeline-local x)
  function visibleTimelineRange(tw) {
    const left = timelineLeftForWidth(tw);
    // timeline's internal x that corresponds to container left:
    const xStart = - (left + panX); // may be negative if timeline extends left beyond container
    const xEnd = xStart + containerW();
    return { xStart, xEnd };
  }

  // Convert timeline-local x to year (float)
  function yearForX(x, tw) {
    const yearSpan = yearSpanPixelsForZoom(zoom);
    const norm = (x - edgeMarginPx) / (yearSpan || 1);
    return startYear + norm * totalYears;
  }

  // Render only visible ticks & events (with small buffer)
  function render() {
    timeline.innerHTML = '';
    const tw = timelineWidthForZoom(zoom);
    const left = timelineLeftForWidth(tw);

    // Set timeline element size and translate
    timeline.style.width = Math.max(tw, 1) + 'px';
    timeline.style.height = containerH() + 'px';
    timeline.style.transform = `translateX(${left + panX}px)`;

    // draw axis baseline
    const axis = document.createElement('div');
    axis.className = 'axis';
    timeline.appendChild(axis);

    // compute visible range with buffer
    const bufferPx = Math.max(200, containerW() * 0.25); // buffer so ticks/events pre-render a bit offscreen
    const { xStart, xEnd } = visibleTimelineRange(tw);
    const visStart = xStart - bufferPx;
    const visEnd = xEnd + bufferPx;

    // draw ticks only in visible range
    const step = tickStepFor(tw);
    // compute approximate year range
    let startYearF = Math.floor(yearForX(visStart < 0 ? 0 : visStart, tw));
    let endYearF   = Math.ceil(yearForX(visEnd > tw ? tw : visEnd, tw));
    // clamp to bounds
    startYearF = Math.max(startYear, startYearF);
    endYearF = Math.min(endYear, endYearF);

    // compute first tick aligned to step
    const firstTick = Math.floor(startYearF / step) * step;
    for (let y = firstTick; y <= endYear && y <= endYear; y += step) {
      if (y < startYear) continue;
      if (y > endYear) break;
      const xLocal = xInTimelineForYear(y, tw);
      // skip ticks wholly outside [visStart, visEnd]
      if (xLocal < visStart || xLocal > visEnd) continue;
      const tick = document.createElement('div');
      tick.className = 'tick';
      tick.style.left = xLocal + 'px';
      timeline.appendChild(tick);

      const lbl = document.createElement('div');
      lbl.className = 'tick-year';
      lbl.textContent = y;
      lbl.style.left = xLocal + 'px';
      timeline.appendChild(lbl);
    }

    // Place only visible events (plus buffer)
    // Sort events chronologically for stable stacking
    const visibleEvents = [];
    for (const e of events) {
      const xLocal = xInTimelineForYear(e.year, tw);
      if (xLocal >= visStart && xLocal <= visEnd) visibleEvents.push({ e, xLocal });
    }
    visibleEvents.sort((a,b) => a.e.year - b.e.year);

    // Stack events by real bounding-box overlap
    const placed = [];
    const baseBottom = 80;
    for (const item of visibleEvents) {
      const e = item.e;
      const xLocal = item.xLocal;
      const el = document.createElement('div');
      el.className = 'event';
      el.textContent = e.label;
      el.style.left = xLocal + 'px';
      el.style.bottom = baseBottom + 'px';
      const arrow = document.createElement('div');
      arrow.className = 'arrow-up';
      el.appendChild(arrow);
      timeline.appendChild(el);

      // collision stacking measured in viewport coordinates
      // give the browser a chance to layout; measure immediately
      let stackLevel = 0;
      const MAX_STACK = 60; // safety
      function rect(node) { return node.getBoundingClientRect(); }
      el.style.bottom = (baseBottom + stackLevel * 28) + 'px';
      let r = rect(el);
      while (true) {
        let collided = false;
        for (const other of placed) {
          const ro = rect(other);
          // horizontal overlap
          const horiz = !(r.right <= ro.left || r.left >= ro.right);
          const vert  = !(r.bottom <= ro.top || r.top >= ro.bottom);
          if (horiz && vert) { collided = true; break; }
        }
        if (!collided) break;
        stackLevel++;
        if (stackLevel > MAX_STACK) break;
        el.style.bottom = (baseBottom + stackLevel * 28) + 'px';
        r = rect(el);
      }
      placed.push(el);
    }

    // Clamp pan after DOM changes
    panX = clampPanFor(tw);
    timeline.style.transform = `translateX(${left + panX}px)`;
  }

  // Zoom maintaining the containerX point
  function performZoom(factor, containerX = null) {
    const oldTw = timelineWidthForZoom(zoom);
    const oldZoom = zoom;
    const newZoom = Math.min(maxZoom, Math.max(minZoom, zoom * factor));
    if (newZoom === zoom) return;
    // default center at container center
    if (containerX === null) containerX = containerW() / 2;

    // compute normalized point along timeline (0..1) under containerX before zoom
    const leftOld = timelineLeftForWidth(oldTw);
    const xInTimeline_old = containerX - (leftOld + panX);
    const norm = (xInTimeline_old - edgeMarginPx) / (yearSpanPixelsForZoom(oldZoom) || 1);

    // clamp norm
    const normClamped = Math.min(Math.max(norm, 0), 1);

    // apply zoom
    zoom = newZoom;

    // compute new timeline width and left
    const newTw = timelineWidthForZoom(zoom);
    const leftNew = timelineLeftForWidth(newTw);

    // compute panX so the same normalized point stays under containerX
    panX = containerX - leftNew - (edgeMarginPx + normClamped * yearSpanPixelsForZoom(zoom));
    panX = clampPanFor(newTw);
    render();
  }

  // Simple pan handlers
  let dragging = false;
  let lastX = 0;
  function startDrag(clientX) {
    dragging = true;
    lastX = clientX;
    container.style.cursor = 'grabbing';
  }
  function endDrag() {
    dragging = false;
    container.style.cursor = 'grab';
  }
  function moveDrag(clientX) {
    if (!dragging) return;
    const dx = clientX - lastX;
    lastX = clientX;
    panX += dx;
    panX = clampPanFor(timelineWidthForZoom(zoom));
    // incremental render (only visible items) keeps it fast
    render();
  }

  // wheel zoom
  function handleWheel(e) {
    if (e.ctrlKey || e.metaKey) return; // let browser zoom
    e.preventDefault();
    const delta = e.deltaY || -e.wheelDelta;
    const factor = delta < 0 ? 1.12 : 1 / 1.12;
    const rect = container.getBoundingClientRect();
    const x = e.clientX - rect.left;
    performZoom(factor, x);
  }

  // touch support (pinch + pan)
  let touchState = { pinchStartDist: null, pinchStartZoom: null, lastMidX: null };
  container.addEventListener('touchstart', (ev) => {
    if (ev.touches.length === 1) {
      startDrag(ev.touches[0].clientX);
    } else if (ev.touches.length === 2) {
      const a = ev.touches[0], b = ev.touches[1];
      touchState.pinchStartDist = Math.hypot(b.clientX - a.clientX, b.clientY - a.clientY);
      touchState.pinchStartZoom = zoom;
      touchState.lastMidX = (a.clientX + b.clientX) / 2 - container.getBoundingClientRect().left;
    }
  }, { passive: false });

  container.addEventListener('touchmove', (ev) => {
    if (ev.touches.length === 1 && dragging) {
      moveDrag(ev.touches[0].clientX);
    } else if (ev.touches.length === 2 && touchState.pinchStartDist) {
      const a = ev.touches[0], b = ev.touches[1];
      const dist = Math.hypot(b.clientX - a.clientX, b.clientY - a.clientY);
      const factor = dist / touchState.pinchStartDist;
      const newZoom = Math.min(maxZoom, Math.max(minZoom, touchState.pinchStartZoom * factor));
      // apply as performZoom using ratio
      const ratio = newZoom / zoom;
      performZoom(ratio, touchState.lastMidX);
    }
    ev.preventDefault();
  }, { passive: false });

  container.addEventListener('touchend', () => {
    endDrag();
    touchState.pinchStartDist = null;
    touchState.pinchStartZoom = null;
  });

  // mouse handlers
  container.addEventListener('mousedown', (e) => { startDrag(e.clientX); });
  window.addEventListener('mouseup', (e) => { endDrag(); });
  window.addEventListener('mousemove', (e) => { moveDrag(e.clientX); });
  container.addEventListener('wheel', handleWheel, { passive: false });

  // zoom buttons
  btnZoomIn.addEventListener('click', () => performZoom(1.4, containerW()/2));
  btnZoomOut.addEventListener('click', () => performZoom(1/1.4, containerW()/2));

  // resize handling
  let resizeTimeout = null;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      const centerX = containerW() / 2;
      // preserve center year by mapping center -> year and then recenter after init
      const twOld = timelineWidthForZoom(zoom);
      const leftOld = timelineLeftForWidth(twOld);
      const xInTimeline_old = centerX - (leftOld + panX);
      const norm = (xInTimeline_old - edgeMarginPx) / (yearSpanPixelsForZoom(zoom) || 1);
      initBase();
      // compute new pan to keep same normalized center
      const newTw = timelineWidthForZoom(zoom);
      const leftNew = timelineLeftForWidth(newTw);
      panX = centerX - leftNew - (edgeMarginPx + norm * yearSpanPixelsForZoom(zoom));
      panX = clampPanFor(newTw);
      render();
    }, 120);
  });

  // initialize & render
  function start() {
    initBase();
    panX = 0;
    render();
    container.style.cursor = 'grab';
  }

  start();

  // Expose for quick debugging if needed
  window.TimelineDebug = {
    getState: () => ({ zoom, panX, basePixelsPerYear, edgeMarginPx }),
    setEdgeMargin: (v) => { edgeMarginPx = Number(v); render(); } // if you want to tweak live
  };

})();
</script>

</body>
</html>

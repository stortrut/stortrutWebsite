<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Zoomable Timeline Corrected</title>
<style>
  body {
    margin: 0;
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    background: #f5f5f5;
  }

  #controls {
    margin: 20px;
  }

  button {
    padding: 6px 12px;
    font-size: 16px;
  }

  #timeline-container {
    width: 100%;
    height: 300px;
    overflow-x: auto;
    overflow-y: hidden;
    border-top: 1px solid #aaa;
    border-bottom: 1px solid #aaa;
    background: white;
    cursor: grab;
    position: relative;
  }

  #timeline {
    position: relative;
    height: 100%;
  }

  .tick {
    position: absolute;
    width: 1px;
    background: #000;
    bottom: 0;
    height: 60px;
  }

  .tick-year {
    position: absolute;
    bottom: 20px;
    transform: translateX(-50%);
    font-size: 12px;
    white-space: nowrap;
    z-index: 1;
  }

  .event {
    position: absolute;
    font-size: 12px;
    white-space: nowrap;
    background: #eee;
    padding: 2px 4px;
    border: 1px solid #ccc;
    border-radius: 3px;
    z-index: 2;
  }

  .arrow.up {
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-bottom: 6px solid #333;
  }
</style>
</head>
<body>

<div id="controls">
  <button id="zoom-in">Zoom In +</button>
  <button id="zoom-out">Zoom Out -</button>
</div>

<div id="timeline-container">
  <div id="timeline"></div>
</div>

<script id="timeline-config" type="application/json">
{
  "startYear": 0,
  "endYear": 900,
  "events": [
    { "year": 100, "label": "Battle of Something" },
    { "year": 102, "label": "Coronation" },
    { "year": 105, "label": "Treaty Signed" },
    { "year": 400, "label": "Great Discovery" },
    { "year": 800, "label": "Mysterious Event" },
    { "year": 801, "label": "Close Event" },
    { "year": 802, "label": "Close Again" }
  ]
}
</script>

<script>
const config = JSON.parse(document.getElementById('timeline-config').textContent);
const startYear = config.startYear;
const endYear = config.endYear;
const events = config.events;

const container = document.getElementById('timeline-container');
const timeline = document.getElementById('timeline');
const zoomIn = document.getElementById('zoom-in');
const zoomOut = document.getElementById('zoom-out');

let basePixelsPerYear = 1; // will scale dynamically
let zoomLevel = 1;
const maxZoom = 10;
const minZoom = 0.01;

// Initialize basePixelsPerYear so first and last year span a reasonable width
function initBasePixels() {
  basePixelsPerYear = container.clientWidth * 0.8 / (endYear - startYear);
}

// Adaptive tick step based on zoom
function getTickStep() {
  const ppy = basePixelsPerYear * zoomLevel;
  if (ppy >= 50) return 1;
  if (ppy >= 20) return 5;
  if (ppy >= 10) return 10;
  if (ppy >= 5) return 50;
  return 100;
}

// Render timeline
function renderTimeline() {
  timeline.innerHTML = '';
  const ppy = basePixelsPerYear * zoomLevel;
  const totalYears = endYear - startYear;
  const width = ppy * totalYears;
  timeline.style.width = width + 'px';

  // Draw ticks
  const step = getTickStep();
  for (let y = startYear; y <= endYear; y += step) {
    const x = (y - startYear) * ppy;
    const tick = document.createElement('div');
    tick.className = 'tick';
    tick.style.left = x + 'px';
    timeline.appendChild(tick);

    const label = document.createElement('div');
    label.className = 'tick-year';
    label.textContent = y;
    label.style.left = x + 'px';
    timeline.appendChild(label);
  }

  // Place events, stacking dynamically based on bounding box overlap
  const placedEvents = [];
  events.forEach(e => {
    const x = (e.year - startYear) * ppy;
    const el = document.createElement('div');
    el.className = 'event';
    el.textContent = e.label;
    el.style.left = x + 'px';
    el.style.transform = 'translateX(-50%)';

    const arrow = document.createElement('div');
    arrow.className = 'arrow up';
    el.appendChild(arrow);
    timeline.appendChild(el);

    // Stack above if overlapping previous events
    let bottom = 60;
    while (true) {
      let overlap = false;
      const rect = el.getBoundingClientRect();
      for (let other of placedEvents) {
        const otherRect = other.getBoundingClientRect();
        if (
          rect.left < otherRect.right &&
          rect.right > otherRect.left &&
          rect.bottom > otherRect.top &&
          rect.top < otherRect.bottom
        ) {
          overlap = true;
          break;
        }
      }
      if (!overlap) break;
      bottom += 26;
      el.style.bottom = bottom + 'px';
    }
    el.style.bottom = bottom + 'px';
    placedEvents.push(el);
  });
}

// Zoom function (scale around centerX)
function zoom(factor, centerX = null) {
  const oldZoom = zoomLevel;
  zoomLevel = Math.min(Math.max(zoomLevel * factor, minZoom), maxZoom);
  if (centerX === null) centerX = container.clientWidth / 2;
  const scrollLeft = container.scrollLeft;
  const yearAtCenter = scrollLeft / oldZoom / basePixelsPerYear;
  renderTimeline();
  container.scrollLeft = yearAtCenter * basePixelsPerYear * zoomLevel;
}

// Event listeners
zoomIn.addEventListener('click', () => zoom(1.5));
zoomOut.addEventListener('click', () => zoom(1/1.5));

container.addEventListener('wheel', e => {
  if (e.ctrlKey || e.metaKey) return;
  e.preventDefault();
  const rect = container.getBoundingClientRect();
  zoom(e.deltaY < 0 ? 1.2 : 1/1.2, e.clientX - rect.left);
});

// Dragging
let isDragging = false;
let dragStartX = 0;
let scrollStart = 0;
container.addEventListener('mousedown', e => {
  isDragging = true;
  dragStartX = e.clientX;
  scrollStart = container.scrollLeft;
  container.style.cursor = 'grabbing';
});
document.addEventListener('mouseup', () => {
  isDragging = false;
  container.style.cursor = 'grab';
});
document.addEventListener('mousemove', e => {
  if (isDragging) {
    container.scrollLeft = scrollStart - (e.clientX - dragStartX);
  }
});

// Initialize
window.addEventListener('resize', () => {
  initBasePixels();
  renderTimeline();
});
window.addEventListener('load', () => {
  initBasePixels();
  renderTimeline();
  container.scrollLeft = 0;
});
</script>

</body>
</html>
